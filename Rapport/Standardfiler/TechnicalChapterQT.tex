\section{Qt}
%short introduction to the chapter
Qt, pronounced "cute", is an open source cross-platform framework, mostly used for GUI(graphical user interface) programming. Qt has an easy to (re)use API(application programming interface), which in return gives high developer productivity. QT is C++ class library, hence new developers using Qt should have some understanding of C++.
This chapter introduces terminologies used in Qt, and tries to give some general insight to how Qt operates and works regarding GUI development. For more information please refer to \citep{Qt Documentation}.

%Maybe something about licencing and version used.


%somewhere here should the "simple" inheritance diagram be.

\subsection{Qt Class Hierarchy and Object Model}
\label{sec:QtClassHierarchyAndObjectModel}
Qt broadly uses inheritance to create subclasses of instances in a natural way. QObject is the most basic class in Qt, see FIGURE. A lot of classes inherit from QObject, like QWidget, which is the base of all user interface objects. 
C++ offers efficient runtime for a object oriented scheme, but lacks in regard to flexibility due to the static nature of the C++ Object Model. Qt has implemented the QObject as the hearth of the Qt Object Model, which preserve the efficient runtime while also offering more flexibility for the GUI domain. The Qt Object Model is implemented with standard C++ techniques. Some of the features that the Qt Object Model adds are e.g.

\begin{itemize}
\item Inter-Object Communication called Signal and Slots in the Qt Object Model. This topic is expanded upon in section~\ref{sec:signalandslots}.
\item Object Trees which structures ownership of objects in a natural fashion. This topic is expanded upon in section~\ref{sec:qwidgets}.
\end{itemize}

\subsubsection{The Meta-Object System}
Due to the Qt Object Model the Meta-Object System was in turn created, which on the bottom line provides the Signal and Slots for inter-object communication and other features from the the QT Object Model. The Meta-Object System is based on three things:
\begin{enumerate*}[label={\alph*)},font={\color{red!50!black}\bfseries}]
\item the QObject class
\item the Q\_OBJECT macro and
\item the Meta-Object compiler(moc).
\end{enumerate*}
Each QObject or subclass of QObject has an instance of QMetaObject created to hold the meta-data information, e.g. the name of the class or the class's meta-methods(signal, slots and other member functions). The Q\_OBJECT macro helps and defines the meta data for the moc at compile time. Please refer to figure~\ref{fig:QtC++BuildProcess} to see influence of the Meta-Object System in compile time.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.55]{Figures/QtC++BuildProcess.png}
	\caption{This figure shows how the the Meta-Object System is integrated at compile time. The yellow boxes indicate the normal C++ compiling procedure, whereas the green box is the added moc, which is compiled into the object files}
	\label{fig:QtC++BuildProcess}
\end{figure}

\subsection{QWidgets}
\label{sec:qwidgets}
QWidget is the base of all user interface objects(buttons, menus etc.). QWidget handles all events from the system the application is running on, i.e. In Qt, events are QEvent objects which is created upon outside activity (like a click on a mouse). Subclasses of QEvent involve more parameters to characterize a certain event, e.g. mousePressEvent(QMouseEvent* event). The event object is then sent to a specific QWidget object (maybe a button) and the QWidget handles the event with the according event handler.\\

As mentioned in~\ref{sec:QtClassHierarchyAndObjectModel} ownership of objects is structured in a tree, this means that a QWidget can have QWidget's within it self, see figure~\ref{fig:QWidgetExample}. A QWidget with no parent is called a top-level widget, which means the QWidget is an independent window. An instance like QWidget subclass QDialog(a pop up dialog window) is a top-level widget. QDialog can be instantiated with a parent, but the QDialog is still a top-level widget in this case, though the position of the dialog window is now centred relative to the parent.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.55]{Figures/QWidgetExample.png}
	\caption{Qt structures ownership of objects in a parent child relationship. The diagram shows a parent widget with various child widgets in a layout, more on layouts in section~\ref{sec:QLayout}.}
	\label{fig:QWidgetExample}
\end{figure}

When a QWidget is used as a container to hold and group children, the QWidget is called a composite widget. A parent widget is clipped to the size that it children requires, though this can be changed in the widget's size policy. 

\subsubsection{QMainWindow}
QMainWindow is a subclass of QWidget, and is very essential to a Qt GUI application, since the QMainWindow is a framework for the application user interface. As seen on figure~\ref{fig:QMainWindowExample} a QMainWindow can have a menu bar widget, toolbar bar widgets, docked widgets and a status bar widget, though a QMainWindow must have a central widget, even if that widget is only a empty placeholder. 

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.55]{Figures/QMainWindowExample.png}
	\caption{This figure shows how a QMainWindow object looks like. RWS uses QMainWindow as the main application widget.}
	\label{fig:QMainWindowExample}
\end{figure}

QMainWindow is usually a good class to use as the framework for an GUI application, though it is optional whether to use it or not. In the case of RWS, QMainWindow is used, and figure~\ref{fig:QMainWindowExample} nicely reflect the structure of RWS' GUI, where the central widget is a custom subclassed QWidget using Qt GUI modules providing classes for OpenGL integration for graphic rendering. Various plug-ins to RWS are available to be docked in the docking area, or to be top-level windows (more on plug-ins in section~\ref{sec:plugin}) and tool bars and a menu bar are present as well for use.

\subsubsection{QLayout}
\label{sec:QLayout}
QLayout is a subclass of QObject and QLayoutItem and is the base class of geometry managers. QLaoyt and it's subclasses are managers for the layout of a group of widget laid out in an application. All QWidget subclasses can use layouts to manage it's children e.g. figure~\ref{fig:QWidgetExample} uses the parent widget as composite widget with two composite children. The parent on figure~\ref{fig:QWidgetExample} use a QHBoxLayout, which lines the child widgets horizontally and makes each child fill one box. The children then has their own QVBoxLayout, which lines their children (grand children) vertically and assign each of those their own box as well. Figure~\ref{fig:QLayoutCode} shows how an implementation of five arbitrary widgets laid in the layout as in figure~\ref{fig:QWidgetExample}.

\begin{figure}[h]
\centering
\lstset{language=C++} 
\begin{lstlisting}[frame=single]  
QWidget* parent = new QWidget();  			//Parent widget
QHBoxLayout* pL = new QHBoxLayout();		//Layout of the parent widget
QWidget* cL = new QWidget(parent); 			//Left child widget
QVBoxLayout* cLL = new QHBoxLayout();		//Layout of left child widget
QWidget* cR = new QWidget(parent); 			//Right child widget
QVBoxLayout* cRL = new QHBoxLayout();		//Layout of right child widget
pL->addWidget(cR); pL->addWidget(cR);		//add children to layout
parent->setLayout(pL);						//set layout
QWidget* b1 = new QWidget(cL), b2 = new QWidget(cL), b3 = new QWidget(cR),
		 b4 = new QWidget(cR), b5 = new QWidget(cR); //create grandchildren
cLL->addWidget(b1), cLL->addWidget(b2);	//grand children added to layout
cL->setLayout(cLL);					//set layout
cRL->addWidget(b3), cRL->addWidget(b3), cRL->addWidget(b5);				 
cR->setLayout(cRL);			 
\end{lstlisting}
\caption{write stuff}
\label{fig:QLayoutCode} 	
\end{figure}


\subsection{Signal and Slots}
\label{sec:signalandslots}
Communication -> objects
Alternative to callback -> explain callback
Signal and slots -> connect() RET TO FIGURE
Signal -> 
Slot -> normal function (only special thing is it can be connected to a signal) -> found by moc
\subsubsection{Difference between events and Signal/Slots}

\subsection{Plug-in}
\label{sec:plugin}

